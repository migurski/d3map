<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>Map Tiles in D3</title>
        <!-- An exercise in learning D3 for DOM manipulation and transitions.
             Uses CSS (3D) transforms where available, falls back to normal CSS if not.
             Coordinate and tile positioning logic cribbed from Modest Maps. 
             A two day hack... Doubtless still glitches to be ironed out!
             No projections, no layers, no double click, no touching, no overlays.
             Queueing img requests seems overkill but smooths things out a lot.
             (C) 2011 Tom Carden, released under the same BSD license as D3 itself: 
             https://github.com/mbostock/d3/blob/master/LICENSE
             Forks welcome! -->
        <script src="image-queue.js"></script>
        <script src="http://mbostock.github.com/d3/d3.min.js"></script>

        <script id="shader-vs" type="x-shader/x-vertex">
            
            uniform mat4 view;
            
            attribute vec2 pos;
            attribute vec2 tex;
            
            varying vec2 vertex_coord;
            varying vec2 texture_coord;
    
            void main()
            {
                // vec4 fills in the remaining z, w dimensions here
                gl_Position = view * vec4(pos, 0, 1);
                
                vertex_coord = pos;
                texture_coord = tex;
            }
            
        </script>
        <script id="shader-fs" type="x-shader/x-fragment">
            
            precision mediump float;
            
            uniform sampler2D texture_sampler;
    
            varying vec2 vertex_coord;
            varying vec2 texture_coord;
            
            void main()
            {
                gl_FragColor = texture2D(texture_sampler, vec2(texture_coord.s, texture_coord.t)); //vec4(1, 1, 1, 1);
            }
            
        </script>
    
        <script src="gl-boilerplate.js" type="application/javascript"></script>
        <script type="text/javascript">
            
            function theGLPart(tiles, entering, exiting)
            {
                var c = document.getElementById('c')
                    gl = c.getContext('experimental-webgl');
                
                // create the WebGL program, store it in "program"
                
                var vsource = document.getElementById('shader-vs').innerText,
                    fsource = document.getElementById('shader-fs').innerText,
                    program = linkProgram(gl, vsource, fsource);
                
                gl.useProgram(program);

                var vertex_pos_attrib = gl.getAttribLocation(program, 'pos'),
                    vertex_tex_attrib = gl.getAttribLocation(program, 'tex');
            
                gl.enableVertexAttribArray(vertex_pos_attrib);
                gl.enableVertexAttribArray(vertex_tex_attrib);
                
                // set up a texture
                
                var tex_sampler = gl.getUniformLocation(program, 'texture_sampler'),
                    texture = gl.createTexture();
                
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 256*8, 256*8, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.generateMipmap(gl.TEXTURE_2D);
                
                gl.activeTexture(gl.TEXTURE0);
                gl.uniform1i(tex_sampler, 0);
                
                var texture_slots = new Int8Array(8*8),
                    tile_textures = {};
                
                // set up array buffer thingies
                
                var tiles_vertex_buffer = gl.createBuffer(),
                    tiles_texture_buffer = gl.createBuffer(),
                    tiles_index_buffer = gl.createBuffer(),
                    tiles_vertex_array = new Float32Array(256 * 8),
                    tiles_texture_array = new Float32Array(256 * 8),
                    tiles_index_array = new Uint16Array(256 * 6);
            
                // populate triangle indexes
                
                var node_index_list = [0, 1, 2, 0, 2, 3];
                
                for(var i = 0; i < tiles_index_array.length; i++)
                {
                    // base advances the indexes forward to the next square tile
                    var base = 4 * Math.floor(i / 6),
                        off = i % 6;
                    
                    tiles_index_array[i] = base + node_index_list[off];
                }
                
                gl.bindBuffer(gl.ARRAY_BUFFER, tiles_vertex_buffer);
                gl.bufferData(gl.ARRAY_BUFFER, tiles_vertex_array, gl.STATIC_DRAW);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, tiles_texture_buffer);
                gl.bufferData(gl.ARRAY_BUFFER, tiles_texture_array, gl.STATIC_DRAW);
                
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, tiles_index_buffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, tiles_index_array, gl.STATIC_DRAW);

                // set up a view matrix
                
                var view = gl.getUniformLocation(program, 'view');
                    mat4 = new Float32Array([2.0/c.width, 0, 0, 0, 0, -2.0/c.height, 0, 0, 0, 0, 1, 0, -1, 1, 0, 1]);
                
                gl.uniformMatrix4fv(view, false, mat4);
                
                var queue = ImageQueue(),
                    blank = new Image();
                    
                blank.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEAAQMAAABmvDolAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAANQTFRFZmZmfFaCBAAAAB9JREFUGBntwQENAAAAwqD3T20ON6AAAAAAAAAAAL4NIQAAAQWThvcAAAAASUVORK5CYII=';
                setInterval(function() { queue.process() }, 250);
                
                function tileKey(tile)
                {
                    return [tile.z, Math.floor(tile.c), Math.floor(tile.r)].join('/');
                }
                
                function cancelTile(tile)
                {
                    var src = 'slimjim.php?url=http://tile.stamen.com/toner/'+tileKey(tile)+'.png';

                    queue.cancel(src);
                    
                    // console.log('canceled', tileKey(tile));
                }
                
                var tileindex = 0;
                
                function loadTile(tile, s, t)
                {
                    tileindex++;
                    var _tileindex = tileindex;
                
                    var key = tileKey(tile),
                        src = 'slimjim.php?url=http://tile.stamen.com/toner/'+key+'.png';
                    
                    var onload = function(err, img)
                    {
                        if(err != undefined)
                        {
                            // console.log('error in', key, (s*8 + t*64), _tileindex);
                            return;
                        }
                    
                        if(tile_textures.hasOwnProperty(key))
                        {
                            tile_textures[key].loaded = true;
                            gl.texSubImage2D(gl.TEXTURE_2D, 0, s*256*8, t*256*8, gl.RGBA, gl.UNSIGNED_BYTE, img);
                            redraw();
                            
                            // console.log('drawing', key, (s*8 + t*64), _tileindex);

                        } else {
                            // console.log('wiffed', key, (s*8 + t*64), _tileindex);
                        }
                    }
                    
                    tile_textures[key].loaded = false;
                    gl.texSubImage2D(gl.TEXTURE_2D, 0, s*256*8, t*256*8, gl.RGBA, gl.UNSIGNED_BYTE, blank);
                    queue.add(src, onload);
                    
                    // console.log('added', key, (s*8 + t*64), _tileindex);
                }
                
                function prioritizeZoom(zoom)
                {
                    var match = '/toner/' + zoom.toFixed(0) + '/';
                    queue.prioritize(match);
                }

                function redraw()
                {
                    for(var i = 0; i < exiting.length; i++)
                    {
                        cancelTile(exiting[i]);
                        var key = tileKey(exiting[i]);
                    
                        if(tile_textures.hasOwnProperty(key))
                        {
                            texture_slots[tile_textures[key].slot] = 0;
                            delete tile_textures[key];
                        }
                    }

                    for(var i = 0; i < entering.length; i++)
                    {
                        var tile = entering[i],
                            key = tileKey(tile);
                    
                        if(tile_textures.hasOwnProperty(key))
                        {
                            continue;
                        }
                    
                        for(var slot = 0; slot < texture_slots.length; slot++)
                        {
                            // look for a free texture slot
                            if(texture_slots[slot] == 0)
                            {
                                var s = (slot % 8) / 8,
                                    t = Math.floor(slot / 8) / 8;
                                
                                texture_slots[slot] = 1;
                                tile_textures[key] = {tile: tile, slot: slot, s: s, t: t, loaded: null};

                                loadTile(tile, s, t);
                                break;
                            }
                        }
                    }
                    
                    prioritizeZoom(tiles[0].z);
                    
                    for(var i = 0; i < tiles.length; i++)
                    {
                        if(tiles[i].z != tiles[0].z)
                        {
                            break;
                        }
                    
                        var x = tiles[i].x,
                            y = tiles[i].y,
                            w = tiles[i].w,
                            h = tiles[i].h,
                            off = i * 8;
                        
                        tiles_vertex_array[off + 0] = x;
                        tiles_vertex_array[off + 1] = y;
                        tiles_vertex_array[off + 2] = x + w;
                        tiles_vertex_array[off + 3] = y;
                        tiles_vertex_array[off + 4] = x + w;
                        tiles_vertex_array[off + 5] = y + h;
                        tiles_vertex_array[off + 6] = x;
                        tiles_vertex_array[off + 7] = y + h;
                        
                        var nativeTile = tiles[i],
                            currentTile = nativeTile;
                        
                        while(true)
                        {
                            var key = tileKey(currentTile),
                                zoomedTile = {z: currentTile.z-1, c: currentTile.c/2, r: currentTile.r/2};
                            
                            if(tile_textures.hasOwnProperty(key) && tile_textures[key].loaded)
                            {
                                var s = tile_textures[key].s, t = tile_textures[key].t;
                                
                                s += (currentTile.c - Math.floor(currentTile.c)) * 1/8;
                                t += (currentTile.r - Math.floor(currentTile.r)) * 1/8;
                                
                                // possibly shrink the step
                                var step = Math.pow(2, currentTile.z - nativeTile.z) * 1/8;
                                
                                tiles_texture_array[off + 0] = s;
                                tiles_texture_array[off + 1] = t;
                                tiles_texture_array[off + 2] = s + step;
                                tiles_texture_array[off + 3] = t;
                                tiles_texture_array[off + 4] = s + step;
                                tiles_texture_array[off + 5] = t + step;
                                tiles_texture_array[off + 6] = s;
                                tiles_texture_array[off + 7] = t + step;
                                
                                break;
                            }
                            
                            key = tileKey(nativeTile);
                            
                            // have we run off the end?
                            if(currentTile.z == 0)
                            {
                                if(tile_textures.hasOwnProperty(key))
                                {
                                    var s = tile_textures[key].s, t = tile_textures[key].t;
                                    
                                    var step = 1/8;
                                    
                                    tiles_texture_array[off + 0] = s;
                                    tiles_texture_array[off + 1] = t;
                                    tiles_texture_array[off + 2] = s + step;
                                    tiles_texture_array[off + 3] = t;
                                    tiles_texture_array[off + 4] = s + step;
                                    tiles_texture_array[off + 5] = t + step;
                                    tiles_texture_array[off + 6] = s;
                                    tiles_texture_array[off + 7] = t + step;
                                }

                                break;
                            }
                            
                            currentTile = zoomedTile;
                        }
                    }
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, tiles_vertex_buffer);
                    gl.bufferData(gl.ARRAY_BUFFER, tiles_vertex_array, gl.STATIC_DRAW);
                    gl.vertexAttribPointer(vertex_pos_attrib, 2, gl.FLOAT, false, 0, 0);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, tiles_texture_buffer);
                    gl.bufferData(gl.ARRAY_BUFFER, tiles_texture_array, gl.STATIC_DRAW);
                    gl.vertexAttribPointer(vertex_tex_attrib, 2, gl.FLOAT, false, 0, 0);
                    
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, tiles_index_buffer);
                    gl.drawElements(gl.TRIANGLES, i * 6, gl.UNSIGNED_SHORT, 0);
                }
                
                return redraw;
            }
        
        </script>
        <script type="text/javascript">
        
            // borrowed from Modest Maps, inspired by LeafletJS
            var transformProperty = (function(props) {
                var style = document.documentElement.style;
                for (var i = 0; i < props.length; i++) {
                    if (props[i] in style) {
                        return props[i];
                    }
                }
                return false;
            })(['transform', '-webkit-transform', '-o-transform', '-moz-transform', '-ms-transform']);

            var matrixString = (function() {
                if (('WebKitCSSMatrix' in window) && ('m11' in new WebKitCSSMatrix())) {
                    return function(scale,x,y,cx,cy) {
                        scale = scale || 1;
                        return 'translate3d(' + [ x, y, '0px' ].join('px,') + ') scale3d(' + [ scale,scale,1 ].join(',') + ')';
/*                        return 'matrix3d(' +
                            [ scale, '0,0,0,0',
                              scale, '0,0,0,0,1,0',
                              (x + ((cx * scale) - cx)).toFixed(4),
                              (y + ((cy * scale) - cy)).toFixed(4),
                              '0,1'].join(',') + ')'; */
                    }
                } else {
                    return function(scale,x,y,cx,cy) {
                        var unit = (transformProperty == 'MozTransform') ? 'px' : '';
                        return 'matrix(' +
                            [(scale || '1'), 0, 0,
                            (scale || '1'),
                            (x + ((cx * scale) - cx)) + unit,
                            (y + ((cy * scale) - cy)) + unit
                            ].join(',') + ')';
                    }
                }
            })();

            // make a tile provider that knows how to wrap tiles around the world
            function provider(tile) {
                var c = {r: tile.r, c: tile.c, z: tile.z};
                var minCol = 0, 
                    maxCol = Math.pow(2,tile.z);                        
                while (c.c < minCol) c.c += maxCol;
                while (c.c >= maxCol) c.c -= maxCol;
                var z = c.z, x = c.c, y = c.r;
                return 'http://otile1.mqcdn.com/tiles/1.0.0/osm/'+z+'/'+x+'/'+y+'.jpg';
            }
            
            // ----- Tile Positioning Functions
            
            // ----- end Tile Positioning Functions
            
           /**
            * Collection of static functions for operating on coordinates.
            *
            * Coordinates are simple objects with three properties:
            * "r" (row), "c" (column), and "z" (zoom).
            */
            var Coordinates = {
            
               /**
                * Return a new coordinate, zoomed by the given amount.
                */
                zoomedBy: function(c, dz)
                {
                    var power = Math.pow(2, dz);
                    return {c: c.c * power, r: c.r * power, z: c.z + dz};
                },
                
               /**
                * Return a new coordinate, offset by the given coordinate.
                */
                offsetBy: function(c, o)
                {
                    return {c: c.c + o.c, r: c.r + o.r, z: c.z + o.z};
                },
                
               /**
                * Return a new round-number coordinate containing the given coordinate.
                */
                container: function(c)
                {
                    c = Coordinates.zoomedBy(c, Math.round(c.z) - c.z);
                    return {c: Math.floor(c.c), r: Math.floor(c.r), z: c.z};
                }
            
            };
            
            function Grid(parent)
            {
                var coord = {c: 2, r: 2, z: 2}, // col, row, zoom
                    roundCoord = null,          // coord at an integer zoom level
                    tileSize = {w: 256, h: 256},// px
                    w = window.innerWidth,
                    h = window.innerHeight,
                    center = {x: w/2, y: h/2 }; // center of map in pixels
                    
                var map = d3.select(parent);
                
                d3.timer(redraw);
                
                map.on('mousedown.map', onMouseDown)
                   .on('mousewheel.map', onWheel)
                   .on('DOMMouseScroll.map', onWheel);
                
                d3.select(window).on('resize.map', onResize);
    
               /**
                * Return CSS left property value for a tile.
                *
                * Remove Math.round() for greater accuracy but visible seams
                */
                function left(tile)
                { 
                    var scale = Math.pow(2, coord.z - tile.z),
                        power = Math.pow(2, tile.z - roundCoord.z),
                        centerCol = roundCoord.c * power;
                    return Math.round(center.x + (tile.c - centerCol) * tileSize.w * scale) + 'px'; 
                }

               /**
                * Return CSS top property value for a tile.
                *
                * Remove Math.round() for greater accuracy but visible seams
                */
                function top(tile)
                { 
                    var scale = Math.pow(2, coord.z - tile.z),
                        power = Math.pow(2, tile.z - roundCoord.z),
                        centerRow = roundCoord.r * power;
                    return Math.round(center.y + (tile.r - centerRow) * tileSize.h * scale) + 'px'; 
                }

               /**
                * Return CSS width property value for a tile.
                *
                * Remove Math.ceil() for greater accuracy but visible seams
                */
                function width(tile)
                {
                    var scale = Math.pow(2, coord.z - tile.z);
                    return Math.ceil(scale * tileSize.w)+'px'; 
                }

               /**
                * Return CSS height property value for a tile.
                *
                * Remove Math.ceil() for greater accuracy but visible seams
                */
                function height(tile)
                { 
                    var scale = Math.pow(2, coord.z - tile.z);
                    return Math.ceil(scale * tileSize.h)+'px'; 
                }          
                
               /**
                * Return CSS transform property value for a tile.
                *
                * For 3D webkit mode
                */
                function transform(tile)
                {
                    var scale = Math.pow(2, coord.z - tile.z);
                    // adjust to nearest whole pixel scale (thx @tmcw)
                    if (scale * tileSize.w % 1) {
                        scale += (1 - scale * tileSize.w % 1) / tileSize.w;
                    }                
                    var zoomedCoord = Coordinates.zoomedBy(roundCoord, tile.z - roundCoord.z),
                        x = Math.round(center.x + (tile.c - zoomedCoord.c) * tileSize.w * scale),
                        y = Math.round(center.y + (tile.r - zoomedCoord.r) * tileSize.h * scale);
                    return matrixString(scale, x, y, tileSize.w/2.0, tileSize.h/2.0);
                }
                
                // don't show above/below the poles
                function validCoordinateFilter(tile)
                {
                    var minRow = 0, 
                        maxRow = Math.pow(2, tile.z);                    

                    return minRow <= tile.r && tile.r < maxRow;                
                }
                
                var visibleCoords = [];
                var status = {coords: visibleCoords, dirty: false, entering: [], exiting: []};

                function redraw()
                {
                    status.dirty = true;
                
                    // apply coord limits
                    if (coord.z > 18) {
                        coord = Coordinates.zoomedBy(coord, 18-coord.z);
                    } else if (coord.z < 0) {
                        coord = Coordinates.zoomedBy(coord, -coord.z);
                    }
                    
                    // find coordinate extents of map
                    var tl = Coordinates.offsetBy(coord, {c: -center.x / tileSize.w, r: -center.y / tileSize.h, z: 0}),
                        br = Coordinates.offsetBy(coord, {c: center.x / tileSize.w, r: center.y / tileSize.h, z: 0});

                    // round coords to "best" zoom level
                    roundCoord = Coordinates.zoomedBy(coord, Math.round(coord.z)-coord.z);
                    tl = Coordinates.zoomedBy(tl, Math.round(tl.z)-tl.z);
                    br = Coordinates.zoomedBy(br, Math.round(br.z)-br.z);

                    // generate visible tile coords           
                    var padding = 0;
                    var cols = d3.range( Math.floor(tl.c) - padding, Math.ceil(br.c) + padding),
                        rows = d3.range( Math.floor(tl.r) - padding, Math.ceil(br.r) + padding);
                    
                    visibleCoords.splice(0, visibleCoords.length);
                    
                    rows.forEach(function(row) {
                        cols.forEach(function(col) {
                            var coord = {c: col, r: row, z: roundCoord.z};
                            
                            if(validCoordinateFilter(coord))
                            {
                                // attach an (x, y) for use outside Grid()
                                coord.x = parseInt(left(coord));
                                coord.y = parseInt(top(coord));
                                coord.w = parseInt(width(coord));
                                coord.h = parseInt(height(coord));

                                visibleCoords.push(coord);
                            }
                        });
                    });
                    
                    // explicitly preserve parent tiles for tiles we haven't already loaded
                    // not strictly necessary but helps with continuity on slow connections
                    var compensationCoords = [];
                        uniqueCompensations = {};

                    function addParentIfNeeded(tile)
                    {
                        if (tile.z > 0 && tile.z > coord.z - 10) {
                            tile = Coordinates.container(Coordinates.zoomedBy(tile, -1));
                            src = provider(tile);
                            if (!(src in uniqueCompensations))
                            {
                                uniqueCompensations[src] = true;
                                compensationCoords.push(tile);
                            }
                            // better continuity if we loop, but slower (needs tuning)
                            addParentIfNeeded(tile);
                        }
                    }

                    visibleCoords.forEach(addParentIfNeeded);
                    
                    for(var i = 0; i < compensationCoords.length; i++)
                    {
                        visibleCoords.push(compensationCoords[i]);
                    }

                    // Takes the place of just String on coordinates below
                    function coordString(c) { return [c.c, c.r, c.z].toString() };
                    
                    var tiles = map.selectAll('div.tile')
                       .data(visibleCoords, coordString);

                    status.entering.splice(0, status.entering.length);
                    status.exiting.splice(0, status.exiting.length);
                    
                    // setup new things                        
                    tiles.enter().append('div')
                        .attr("id", coordString)
                        .attr("class", "tile")
                        //.text(coordString)
                        .each(function(tile) { status.entering.push(tile) });

                    // TODO: on('error')?

                    // clean up old things
                    tiles.exit().remove()
                        .each(function(tile) { status.exiting.push(tile) });
                    
                    // update all positions, enter/update/exit alike
                    if (transformProperty) {
                        map.selectAll('div.tile')
                            .style(transformProperty, transform);                        
                    } else {
                        map.selectAll('div.tile')
                            .style("left", left)
                            .style("top", top)
                            .style("width", width)
                            .style("height", height);
                    }                    

                    return true;
                }
                
                function onMouseDown()
                {
                    var prevMouse = {x: d3.event.pageX, y: d3.event.pageY};

                    d3.select(window)
                        .on('mousemove.map', onMouseMove)
                        .on('mouseup.map', onMouseUp)
                    d3.event.preventDefault();
                    d3.event.stopPropagation();                        
                    
                    function onMouseMove()
                    {
                        var mouse = prevMouse;
                        prevMouse = {x: d3.event.pageX, y: d3.event.pageY};
                        coord = Coordinates.offsetBy(coord, {
                            c: -((prevMouse.x - mouse.x) / tileSize.w),
                            r: -((prevMouse.y - mouse.y) / tileSize.h),
                            z: 0
                        });
                        d3.event.preventDefault();
                        d3.event.stopPropagation();
                        d3.timer(redraw);
                    }
                    
                    function onMouseUp()
                    {
                        prevMouse = null;
                        d3.select(window)
                            .on('mousemove.map',null)
                            .on('mouseup.map',null);
                    }
                }
                
                function onWheel() {
                    // 18 = max zoom, 0 = min zoom
                    var delta = Math.min(18-coord.z,Math.max(0-coord.z,d3_behavior_zoomDelta()));
                    if (delta != 0) {
                        var mouse = {x: d3.event.pageX, y: d3.event.pageY};
                        coord = Coordinates.offsetBy(coord, {
                            c: ((mouse.x-center.x) / tileSize.w),
                            r: ((mouse.y-center.y) / tileSize.h),
                            z: 0
                        });
                        coord = Coordinates.zoomedBy(coord, delta);
                        coord = Coordinates.offsetBy(coord, {
                            c: -((mouse.x-center.x) / tileSize.w),
                            r: -((mouse.y-center.y) / tileSize.h),
                            z: 0
                        });
                        d3.timer(redraw);
                    }
                    d3.event.preventDefault();
                    d3.event.stopPropagation();                        
                }
                    
                function onResize()
                {
                    center = {x: window.innerWidth/2, y: window.innerHeight/2}
                    d3.timer(redraw);
                }
                
                return status;
            };

            window.onload = function() {
            
                // Grid returns a reference to the visible coordinates array
                var grid_stat = Grid('#map');
                var redrawGL = theGLPart(grid_stat.coords, grid_stat.entering, grid_stat.exiting);
                
                function animationLoop()
                {
                    requestAnimationFrame(animationLoop);
        
                    if(grid_stat.dirty)
                    {
                        gl.clearColor(0.824, 0.788, 0.580, 1);
                        gl.clear(gl.COLOR_BUFFER_BIT);
                        
                        redrawGL();
                    }
                    
                    grid_stat.dirty = false;
                }
                
                animationLoop();
            }
            
            // expose this so our own mousewheel handler can use it
            var d3_behavior_zoomDiv = null;
            
            // detect the pixels that would be scrolled by this wheel event
            function d3_behavior_zoomDelta() {
            
              // mousewheel events are totally broken!
              // https://bugs.webkit.org/show_bug.cgi?id=40441
              // not only that, but Chrome and Safari differ in re. to acceleration!
              if (!d3_behavior_zoomDiv) {
                d3_behavior_zoomDiv = d3.select("body").append("div")
                    .style("visibility", "hidden")
                    .style("top", 0)
                    .style("height", 0)
                    .style("width", 0)
                    .style("overflow-y", "scroll")
                  .append("div")
                    .style("height", "2000px")
                  .node().parentNode;
              }
            
              var e = d3.event, delta;
              try {
                d3_behavior_zoomDiv.scrollTop = 250;
                d3_behavior_zoomDiv.dispatchEvent(e);
                delta = 250 - d3_behavior_zoomDiv.scrollTop;
              } catch (error) {
                delta = e.wheelDelta || (-e.detail * 5);
              }
            
              return delta * .005;
            }          
            
		</script>
		<style>
		    html, body {
		        background: #ddd;
		        width: 100%;
		        height: 100%;
		        margin: 0;
		        padding: 0;
		        border: 0;
		    }
		    #map {
		        position: relative;
		        overflow: hidden;
		        margin: 0;
		        padding: 0;
		    }
		    #c, #map
		    {
		        border: 1px solid orange;
		        position: absolute;
		        top: 10px;
		        left: 10px;
		    }
		    div.tile,
		    img.tile {
		        display: block;
		        position: absolute;
		        margin: 0;
		        padding: 0;
		        border: 0;
		        -webkit-transform-origin: 0px 0px;
		    }
		    p {
		        font: bold 12px sans-serif;
		        position: absolute;
		        display: block;
		        right: 5px;
		        bottom: 5px;
		        color: white;
		        text-shadow: 1px 1px 4px rgba(0,0,0,0.75);
		        z-index: 250;
		        margin: 0;
		        padding: 5px;
		    }
		    p a {
		        color: white;
		    }
		</style>
    </head>
    <body>
        <canvas id="c" width="1200" height="300"></canvas>
        <div id="map" style="width: 1200px; height: 300px;"></div>
        <p>Tiles &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, CC-BY-SA. Courtesy of <a href="http://www.mapquest.com/" target="_blank">MapQuest</a> <img src="http://developer.mapquest.com/content/osm/mq_logo.png"></p>
    </body>
</html>